<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript 易错知识点整理]]></title>
    <url>%2F2018%2F10%2F18%2FJavaScript%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[变量作用域123456var a = 1;function test() &#123; var a = 2; console.log(a); // 2&#125;test(); 上面的 test 函数作用域中声明并赋值了 a，且在 console 之上，所以遵循就近原则输出 a 等于 2。 123456var a = 1;function test2() &#123; console.log(a); // undefined var a = 2;&#125;test2(); 上方的函数作用域中虽然声明并赋值了 a，但位于 console 之下，a 变量被提升，输出时已声明但尚未被赋值，所以输出 undefined。 123456var a = 1;function test3() &#123; console.log(a); // 1 a = 2;&#125;test3(); 上方的函数作用域中 a 被重新赋值，未被重新声明，且位于 console 之下，所以输出全局作用域中的 a。 123456let b = 1;function test4() &#123; console.log(b); // b is not undefined let b = 2;&#125;test4(); 上方的函数作用域中使用了 ES6 的 let 重新声明了变量 b，而 let 不同于 var 其不存在变量提升的功能，所以输出报错b is not undefined 12345678function test5() &#123; let a = 1; &#123; let a = 2; &#125; console.log(a); // 1&#125;test5(); 上方的函数作用域中用 let 声明了 a 为 1，并在块级作用域中声明了 a 为 2，因为 console 并不在函数内的块级作用域中，所以输出 1。 类型比较1234var arr = [], arr2 = [1];console.log(arr === arr2); // false 上方两个不同的数组比较，console 为 false。 1234var arr = [], arr2 = [];console.log(arr === arr2); // false 上方两个相同的数组比较，因为两个单独的数组永不相等，所以 console 为 false。 1234var arr = [], obj = &#123;&#125;;console.log(typeof arr === typeof obj); // true 上方利用 typeof 比较数组和对象，因为 typeof 获取null、数组、对象的类型都为object，所以 console 为 true。 123var arr = [];console.log(arr instanceof Object); // trueconsole.log(arr instanceof Array); // true 上方利用 instanceof 判断一个变量是否属于某个对象的实例，因为在 JavaScript 中数组也是对象的一种，所以两个 console 都为 true。 this 指向1234567var obj = &#123; name: "xiaoming", getName: function() &#123; return this.name; &#125;&#125;;console.log(obj.getName()); // xiaoming 上方对象方法中的 this 指向对象本身，所以输出 xiaoming 12345678var obj = &#123; name: "xiaoming", getName: function() &#123; return this.name; &#125;&#125;;var nameFn = obj.getName;console.log(nameFn()); // undefined 上方将对象中的方法赋值给了一个变量，此时方法中的 this 也将不再指向 obj 对象，从而指向 window 对象，所以 console 为 undefined。 12345678910111213var obj = &#123; name: "xiaoming", getName: function() &#123; return this.name; &#125;&#125;;var obj2 = &#123; name: "xiaohua"&#125;;var nameFn = obj.getName;console.log(nameFn.apply(obj2)); // xiaohua 上方同样将 obj 对象中的方法赋值给了变量 nameFn，但是通过 apply 方法将 this 指向了 obj2 对象，所以最终 console 为 xiaohua。 函数参数1234function test6() &#123; console.log(Array.prototype.slice.call(arguments)); // [1,2]&#125;test6(1, 2); 上方利用函数中的 arguments 类数组对象获取传入函数的参数数组，所以输出数组[1, 2]。 123456function test7() &#123; return function() &#123; console.log(Array.prototype.slice.call(arguments)); // 未执行到此，无输出 &#125;;&#125;test7(1, 2); 上方同样利用 arguments 获取参数，但因 test7(1, 2)未执行 return 中的函数，所以无输出。若执行 test7(1, 2)(3, 4)则会输出[3, 4]。 123456var args = [1, 2];function test8() &#123; console.log(Array.prototype.slice.call(arguments)); // [1,2,3,4]&#125;Array.prototype.push.call(args,3, 4));test8(...args); 上方利用 Array.prototype.push.call()方法向 args 数组中插入了 3 和 4，并利用 ES6 延展操作符(…)将数组展开并传入 test9，所以 console 为[1, 2, 3, 4]。 闭包问题123456var elem = document.getElementsByTagName("div"); // 如果页面上有5个divfor (var i = 0; i &lt; elem.length; i++) &#123; elem[i].onclick = function() &#123; alert(i); //总是5 &#125;;&#125; 上方是一个很常见闭包问题，点击任何 div 弹出的值总是 5，因为当你触发点击事件的时候 i 的值早已是 5，可以用下面方式解决： 12345678var elem = document.getElementsByTagName("div"); // 如果页面上有5个divfor (var i = 0; i &lt; elem.length; i++) &#123; (function(j) &#123; elem[j].onclick = function() &#123; alert(j); // 依次为 0，1，2，3，4 &#125;; &#125;)(i);&#125; 在绑定点击事件外部封装一个立即执行函数，并将 i 传入该函数即可。 对象拷贝与赋值12345678var obj = &#123; name: "xiaoming", age: 23&#125;;var newObj = obj;newObj.name = "xiaohua";console.log(obj.name); // xiaohuaconsole.log(newObj.name); // xiaohua 上方我们将 obj 对象赋值给了 newObj 对象，从而改变 newObj 的 name 属性，但是 obj 对象的 name 属性也被篡改，这是因为实际上 newObj 对象获得的只是一个内存地址，而不是真正的拷贝，所以 obj 对象被篡改。 123456789var obj2 = &#123; name: "xiaoming", age: 23&#125;;var newObj2 = Object.assign(&#123;&#125;, obj2, &#123; color: "blue" &#125;);newObj2.name = "xiaohua";console.log(obj2.name); // xiaomingconsole.log(newObj2.name); // xiaohuaconsole.log(newObj2.color); // blue 上方利用 Object.assign()方法进行对象的深拷贝可以避免源对象被篡改的可能。因为 Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 12345678var obj3 = &#123; name: "xiaoming", age: 23&#125;;var newObj3 = Object.create(obj3);newObj3.name = "xiaohua";console.log(obj3.name); // xiaomingconsole.log(newObj3.name); // xiaohua 我们也可以使用 Object.create()方法进行对象的拷贝，Object.create()方法可以创建一个具有指定原型对象和属性的新对象。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mathjax与KaTex渲染数学公式]]></title>
    <url>%2F2018%2F09%2F16%2FMathjax%E4%B8%8EKaTex%E6%B8%B2%E6%9F%93%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[我们经常会用 Office Word 在文档中插入数学公式，有没有想过，如何在你的网页上渲染数学公式呢？让我们走进数学，欣赏一下公式渲染的美妙之处。 应用场景我们先来看看都有哪些场景应用到了数学公式，有个整体的印象。此外，可以扩展技术面，让你可以在做技术选型的时候游刃有余： 大数据分析当你要做一些大数据分析的时候，可能会用到很多的算法公式。如何让读者更好的理解内容，你可能需要用到公式渲染。 在线教育的数学试卷渲染毋庸置疑，数学包含了很多公式，很难想象一张试卷没有包含任何数学公式。 富文本编辑器这个可能是最多的场景，甚至你一直在用，却未曾感知。例如：Word 中插入公式，CKeditor 中的公式组件。 学术论文如果你是一个严谨的学者，肯定不会在自己论文中粘贴图片的公式，你可能需要用到公式渲染。 印刷出版刊物印刷出版，数学公式必不可少，没有人可以忍受印在书上的图片公式。因为它可能会失真。 多种选择这里主要介绍两个JS数学公式渲染的类库： Mathjax: A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works. KaTex: The fastest math typesetting library for the web. Mathjax 示例先来看看 Mathjax 的例子，使用方式非常简单，我们引入类库文件： 1&lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async&gt;&lt;/script&gt; 一个简单的例子可能如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Jartto's MathJax Demo &lt;/title&gt;&lt;script type="text/javascript" async src="https://example.com/mathjax/MathJax.js?config=AM_CHTML"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;When `a != 0`, there are two solutions to `ax^2 + bx + c = 0` andthey are&lt;/p&gt;&lt;p style="text-align:center"&gt; `x = (-b +- sqrt(b^2-4ac))/(2a) .`&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 再比如： 12When $a \ne 0$, there are two solutions to \(ax^2 + bx + c = 0\) and they are$$x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;.$$ 渲染后的结果如下：When $a \ne 0$, there are two solutions to (ax^2 + bx + c = 0) and they are$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$我们可以把表达式放到引号里，如下 1`ax^2 + bx + c = 0` 或者 $ 中 1$ax^2 + bx + c = 0$ 使用很简单，详情可以看看文档。 KaTex 示例看完 Mathjax 之后，我们再来了解一下 KaTex: 1.安装 123456789# npmnpm install katexnpm install -g katex# yarnyarn add katexyarn global add katex# Browser&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.css" integrity="sha384-JwmmMju6Z7M9jiY4RXeJLoNb3aown2QCC/cI7JPgmOLsn3n33pdwAj0Ml/CMMd1W" crossorigin="anonymous"&gt;&lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.js" integrity="sha384-atIluo+2Hixq8HCazSQWa1JjeC5L0CQeWAx74Q+EbqgAW4UixbrBQF4+1jvBX01b" crossorigin="anonymous"&gt;&lt;/script&gt; KaTex 支持大部分的浏览器：Chrome, Safari, Firefox, Opera, Edge, and IE 9–11 2.使用 Dom 渲染 TeX 表达式 123katex.render("c = \\pm\\sqrt&#123;a^2 + b^2&#125;", element, &#123; throwOnError: false&#125;); 3.反斜线需要特殊处理 123katex.render(String.raw`c = \pm\sqrt&#123;a^2 + b^2&#125;`, element, &#123; throwOnError: false&#125;); 4.服务端渲染 1234var html = katex.renderToString("c = \\pm\\sqrt&#123;a^2 + b^2&#125;", &#123; throwOnError: false&#125;);// '&lt;span class="katex"&gt;...&lt;/span&gt;' 5.处理自动渲染 首先加载 js 和 css 12&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous"&gt;&lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"&gt; 额外引入 1&lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous"&gt; 使用方式 1234567&lt;script&gt; document.addEventListener("DOMContentLoaded", function() &#123; renderMathInElement(document.body, &#123; // jartto's demo &#125;); &#125;);&lt;/script&gt; 当然，我们也可以这么使用：window.renderMathInElement(elem, options); 6.可用参数 KaTex 能支持很多的场景，缘于它可以灵活的配置。 displayMode throwOnError errorColor macros colorIsTextColor maxSize maxExpand allowedProtocols strict 参数定义可以看这里，我们可以根据场景来配置参数。那么如何使用呢，一个简单的例如可能如下： 123456katex.render("c = \\pm\\sqrt&#123;a^2 + b^2&#125;\\in\\RR", element, &#123; displayMode: true, macros: &#123; "\\RR": "\\mathbb&#123;R&#125;" &#125;&#125;); 7.异常处理 公式排版很细致，但是疏漏不可避免，这时候你可能需要了解一下公式的异常处理。 1234567891011121314try &#123; var html = katex.renderToString(texString); // '&lt;span class="katex"&gt;...&lt;/span&gt;'&#125; catch (e) &#123; if (e instanceof katex.ParseError) &#123; // KaTeX can't parse the expression html = ("Error in LaTeX '" + texString + "': " + e.message) .replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); &#125; else &#123; throw e; // other error &#125;&#125; 8.在线尝试 公式排版不是一件容易的事，为了达到更好的渲染效果，调试必不可少。还好，KaTex 为我们提供了在线调试工具 优缺点 Mathjax 有着更全面的解析，但却丧失了体积轻量这一优势； KaTex 则更加灵活，以高速渲染为优势； 所以，按照使用场景选择合适的类库吧。 万变不离其宗不管是 Mathjax 还是 KaTex 其实都依赖了底层协议，也就是我们常说的 TEX。TEX（希腊语：/tɛx/[1]，音译“泰赫”，文本模式下写作 TeX ），是一个由美国计算机教授高德纳（Donald Ervin Knuth）编写的功能强大的排版软件。它在学术界十分流行，特别是数学、物理学和计算机科学界。 TEX 被普遍认为是一个优秀的排版工具，特别是在处理复杂的数学公式时。利用诸如是 LATEX 等终端软件，TEX 就能够排版出精美的文本以帮助人们辨认和查找。LATEX 是一套以 TEX 描述的宏软件。LATEX 有很多预设的模版、样式。它比 TEX 更为结构化，如包含了供创建索引、表格、列表等的宏和公用软件。 掌握语法既然大家都遵守 TEX 协议，那么就好办了。我们只要掌握底层语法，不管多少个类库都只是包了一层语法糖。那么我们就从语法开始吧，这里我稍作整理，大概如下： 1.换行 \\2.求和 1\displaystyle\sum_0^n 3.比较 1a \gt b 4.分数 1\frac&#123;2&#125;&#123;9&#125; 5.圆弧 1\overgroup&#123;AC&#125; 6.表格 1\begin&#123;array&#125;&#123;|c|c|c|c|c|c|&#125;\hline年龄\left(岁\right)&amp;12&amp;13&amp;14&amp;15&amp;16\\\hline人数&amp;1&amp;4&amp;3&amp;7&amp;5\\\hline\end&#123;array&#125; 7.矩阵 1234\begin&#123;matrix&#125; a &amp; b \\ c &amp; d\end&#123;matrix&#125; 8.条件判断 1234\begin&#123;cases&#125; a &amp;\text&#123;if &#125; b \\ c &amp;\text&#123;if &#125; d\end&#123;cases&#125; 如果感兴趣，可以看这里的文档。 实用技巧1.公式太长，如何换行? 1\frac&#123;a^&#123;2&#125;-1&#125;&#123;a&#125;÷\frac&#123;(a-1)^&#123;2&#125;&#125;&#123;a&#125;=\frac&#123;(a+1)(a-1)&#125;&#123;a&#125;×\frac&#123;a&#125;&#123;(a-1)^&#123;2&#125;&#125;=\frac&#123;a+1&#125;&#123;a-1&#125; 像这样的公式，渲染出来会特别长，甚至超出了屏幕边界，大大影响用户体验。 那我们改一下，使用折行： 1234\begin&#123;alignedat&#125;&#123;2&#125; \frac&#123;a^&#123;2&#125;-1&#125;&#123;a&#125;÷\frac&#123;(a-1)^&#123;2&#125;&#125;&#123;a&#125;= \\ \frac&#123;(a+1)(a-1)&#125;&#123;a&#125;×\frac&#123;a&#125;&#123;(a-1)^&#123;2&#125;&#125;=\frac&#123;a+1&#125;&#123;a-1&#125;\end&#123;alignedat&#125; 这样就完美了～ 2.一定要使用异常捕获 1234567try &#123; return katex.renderToString(jarttoLatex, &#123; displayMode: true &#125;);&#125; catch (e) &#123; // TODO log error latex console.log("katex error", e); return jarttoLatex;&#125; 公式语法还是比较复杂，稍有不慎很容易出错，所以一定要 try catch。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Mathjax</tag>
        <tag>KaTex</tag>
        <tag>TEX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue-worker轻松使用Vue.js]]></title>
    <url>%2F2018%2F09%2F05%2F%E4%BD%BF%E7%94%A8vue-worker%E8%BD%BB%E6%9D%BE%E4%BD%BF%E7%94%A8VueJs%2F</url>
    <content type="text"><![CDATA[像许多开发人员一样，当Web Workers首次出现在Web开发环境中时，我非常热情，并且对我可以用它们完成的各种惊人事情感到厌烦。然而，当我意识到工作人员必须从托管在Web服务器上的单独文件加载时，我的热情很快就受到了打击。这似乎是一个巨大的痛苦，不值得努力。结合API开销，自从我第一次尝试到现在为止，我还没有真正再次使用过工作者。看着vue-worker，我突然惊讶于我的Vue.js应用程序可以通过一个简单的API和没有外部文件来完成什么。 vue-worker（或者说是同一 作者 的 simple-web-worker ）的核心前提是Web Workers可以从Data URI初始化，它可以只是一个字符串化的函数。 vue-worker通过一个简单易懂的API来解决其中涉及的复杂性，允许您像promises一样轻松执行多头函数。 安装通过 Yarn 或 NPM 安装vue-worker：12345# Yarn$ yarn add vue-worker# NPM$ npm install vue-worker --save 现在，启用VueWorker插件：1234567891011// src/main.jsimport Vue from 'vue';import VueWorker from 'vue-worker';import App from 'App.vue';Vue.use(VueWorker);new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;); 这使您的组件能够访问this.$worker。 在Worker中运行函数现在，您可以在组件内部使用this.$worker.run(function, args[])。 这运行一个输出 Hello，World 的函数！在组件安装时的工作线程中：123456789101112131415&lt;script&gt;export default &#123; mounted() &#123; this.$worker.run((arg) =&gt; &#123; return `Hello, $&#123;arg&#125;!` &#125;, ['World']) .then(result =&gt; &#123; console.log(result) &#125;) .catch(e =&gt; &#123; console.error(e) &#125;) &#125;&#125;&lt;/script&gt; 可重复使用 Workers您可以创建可重复使用的worker 代理 this.$worker.create([{message, func}])123456789101112131415161718192021&lt;script&gt;export default &#123; data() &#123; return &#123; myWorker: null &#125; &#125;, created() &#123; this.myWorker = this.$worker.create([ &#123;message: 'message1', func: (arg) =&gt; `Output 1 $&#123;arg&#125;`&#125;, &#123;message: 'message2', func: () =&gt; 'Output 2'&#125; ]) this.myWorker.postMessage('message1', ['Boop!']) .then(result =&gt; &#123; console.log(result) &#125;) &#125;&#125;&lt;/script&gt; 你还可以做更多的事情，看看vue-worker和simple-worker文档。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5与HTML4的区别]]></title>
    <url>%2F2018%2F09%2F01%2FHTML5%E4%B8%8EHTML4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[HTML5 推出的理由解决 Web 上存在的问题： Web 浏览器间的兼容性低: 在一个浏览器中可以运行的 HTML、Css、Javascript，在另一个浏览器中不能运行。 原因： 各浏览器规范不统一，没有被标准化。 解决方案： 使各浏览器的功能符合通用标准。 文档结构不够明确： HTML4 中元素不能把文档结构表示清楚。 解决方案： 增加与结构相关的元素。 Web 应用程序的功能受到限制： HTMLL4 对 Web 应用程序的贡献很小，比如：不允许同时上传多个文件。 解决方案： 提供供 Web 应用程序使用的 API。 HTML5 语法的改变内容类型不变HTML5 的文件扩展符（html 或.htm）与内容类型（text/html）保持不变。DOCTYPE 声明变化 HTML4 中需要指明是 HTML 的哪个版本，HTML5 不需要，只使用&lt;!DOCTYPE html&gt;即可。 指定字符编码变化 HTML4：&lt;meta http-equiv=‶content-type″ content=‶text/html; charset=UTF-8″&gt; HTML5:&lt;meta charset=‶UTF-8″&gt; 可以省略元素的标记 HTML5 中很多元素标记可以省略 具有 boolean 值的属性调整 不指定属性值、属性名设定为属性值、字符串设为空时表示属性值为 true； 不写该属性表示属性值为 false。 例如： 1234567&lt;input type=‶checkbox″ checked&gt; &lt;!--表示checked值为true--&gt;&lt;input type=‶checkbox″ checked=‶checked″&gt; &lt;!-- 表示checked值为true --&gt;&lt;input type=‶checkbox″ checked=‶″&gt; &lt;!-- 表示checked值为true --&gt;&lt;input type=‶checkbox″&gt; &lt;!-- 表示checked值为false --&gt; 可省略引号 HTML5 可省略指定属性值时的引号。 新增的元素和废除的元素新增元素 新增的结构元素 section： 表示页面中内容块，比如章节、页眉、页脚或页面中的其他部分，可与&lt;h1&gt;到&lt;h6&gt;结合使用表示文档结构。 article： 表示页面中一块与上下文不相关的独立内容，比如博客中的一篇文章或报纸中的一篇文章。 aside： 表示 article 内容之外，与 article 内容相关的辅助信息。 header： 表示页面中的区域块，通常用它表示标题。 hgroup： 用于对整个页面或页面中标题进行整合。 footer： 表示页面中的区域块，通常表示区域快的脚部或底部，用于承载作者姓名、创作日期等与作者的元素。 nav: 表示页面中导航部分。 figure：表示一段独立的流内容，一般表示主体流内容的一个独立单元。 新增的其他元素 video： 定义电影片段、视频流等视频。 audio： 定义音乐或音频流。 canvas： 画布，本身没有行为，仅提供一块画布，但它的 API 展现给 JavaScript 及脚本，能够把想绘制的东西绘制在 canvas 上。 embed mark progress meter time ruby rt rp wbr command details detalistdatagrid keygen output source menu 新增的 input 元素的类型 email： 表示必须输的 email 地址 url： 表示文本框输入的一个地址 number： 表示数字 range： 表示数字范围值 DataPickers：表示日历的日期、时间 废除的元素 能使用 css 代替的元素 basefont big center font s tt u 等 不再使用 frame 框架 由于 frame 框架对网页可用性存在负面影响，HTML5 中已不支持 frame 框架，只支持 iframe 框架或者用服务器方式创建的由多个页面组成的复合页面的形式，同时将 frameset 元素、frame 元素、noframes 元素废除。 只有部分浏览器支持的元素 其他被废除的元素 全局属性HTML5中新增全局属性的概念，全局属性指可以对任何元素都使用的属性。 contentEditable属性 允许用户编辑元素中内容，使用该属性的元素必须为可以获得鼠标焦点的元素，而且在点击鼠标后向用户提供一个插入符号，提示用户该元素允许进行编辑。 是boolean值类型，可以设为true、false或继承状态。其中，true代表可编辑，false代表不可编辑，当未指定true或false时与父元素的继承状态相同。 designMode属性 用来指定整个页面是否可编辑，当页面可编辑时，页面中所有支持contentEditable属性的元素都变为可编辑状况。designMode属性只能在JavaScript脚本中被修改、编辑。属性值可取on（可编辑）或off（不可编辑）。 hidden属性 HTML5中所有元素都允许使用hidden属性，该属性类似于input元素中hidden元素，boolean值，可设为true（不可见）、false（可见）。当某元素的hidden属性值为true时，浏览器不渲染该元素，使该元素处于不可见状态，但浏览器创建该元素内容，即页面加载后允许使用JavaScript脚本将该属性值取消，使该元素可见。 spellcheck属性 针对input（type=text）与textarea这两个文本输入框提供的一个新属性，主要对用户输入内容进行拼写与语法检查。属性值为boolean值，可取true或false。 tableindex属性 当点击Tab键时，让窗口或页面中可获得焦点的链接元素或表单元素进行遍历，tableindex表示该元素第几个被访问到。 若tableindex值为”-1”时表示无法获取该元素.]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html4</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown使用指南]]></title>
    <url>%2F2018%2F08%2F26%2FMarkdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言什么是 Markdown？Markdown 是一种轻量级的「标记语言」，通常为程序员群体所用，目前它已是全球最大的技术分享网站 GitHub 和技术问答网站 StackOverFlow 的御用书写格式。非技术类笔记用户，千万不要被「标记」、「语言」吓到，Markdown 的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。就是这十个不到的标记符号，却能让人优雅地沉浸式记录，专注内容而不是纠结排版，达到「心中无尘，码字入神」的境界。 利用 Markdown 可以做什么？标题标题是每篇文章必备而且最常用的格式。在 Markdown 中，如果想将一段文字定义为标题，只需要在这段文字前面加上 #，再在 # 后加一个空格即可。还可增加二、三、四、五、六级标题，总共六级，只需要增加 # ，增加一个 # ，标题字号相应降低一级。代码如下： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果如下： 列表列表格式也很常用，它可以让你的文稿变得井井有条。在 Markdown 中，你只需要在文字前面加上 - 就可以了；如果你希望是有序列表，在文字前面加上 1. 2. 3. 即可。 注：-、1.和文字之间要保留一个字符的空格。 无序列表 123456# 代码- 列表 1 - 列表 1.1 - 列表 1.2- 列表 2- 列表 3 效果如下： 列表 1 列表 1.1 列表 1.2 列表 2 列表 3 无序列表可以用* ， + ， — 来创建，用在线编辑器看，实际上是转换成了 ul&gt;li ，所以使用哪个都可以。 有序列表 1234# 代码1. 列表 12. 列表 23. 列表 3 效果如下：1. 列表 12. 列表 23. 列表 3### 引用如果你需要在文稿中引用一段别处的句子，那么就要用到「引用」格式。在引用文字前加上 &gt; 并与文字保留一个字符的空格，即可。代码如下：123&gt; - 前方高能&gt; &gt; 注意：这里是为了提醒前面有很刺激的事情发生，请做好准备。&gt; &gt; 城市套路深，我要回农村。效果如下： 前方高能  注意：这里是为了提醒前面有很刺激的事情发生，请做好准备。城市套路深，我要回农村。 注：符号与文本之间必须空格。 由上面例子可以看出，想要在上一次引用中嵌套一层引用，只需多加一个&gt;，理论上可以无限嵌套，我就不整那么多了，注意：多层嵌套的&gt;是不需要连续在一起的，只要在一行就可以了，中间允许有空格，但是为了好看，还是把排版搞好吧。 代码框这个就比较重要了，很多时候都需要展示出一些代码如果代码量比较少，只有单行的话，可以用单反引号包起来，如下：单行用 1`&lt;p&gt;&lt;a href="javascript:;"&gt;气宇轩昂&lt;/a&gt;&lt;/p&gt;` 效果如下： &lt;p&gt;&lt;a href=&quot;javascript:;&quot;&gt;气宇轩昂&lt;/a&gt;&lt;/p&gt; 要是多行这个就不行了，多行可以用这个： 效果如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;这是title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 多行用三个反引号，如果要写注释，可以在反引号后面写 链接与图片链接：在 Markdown 中，插入链接只需要使用 [显示文本](链接地址) 即可。 图片：在 Markdown 中，插入图片只需要使用 ![显示文本](图片链接地址)即可。 注：插入图片的语法和链接的语法很像，只是前面多了一个 ! 12345**插入链接：**[气宇轩昂](http://example.com/)**插入图片：**![这是一张图](/uploads/post/home-bg-o.jpg) 效果如下： 插入链接：气宇轩昂 插入图片： 上述方法只是单纯把图片显示出来，无法自定义设置图片大小，如果图片很大的话就会铺满屏幕或者超高，排版上不好看。 通过 img 标签控制宽高: 123&lt;img src="http://pic15.photophoto.cn/20100615/0006019058815826_b.jpg" height="330" width="400"&gt;&lt;!-- 或者 --&gt;&lt;img src="/uploads/post/home-bg-o.jpg" style="height:200px;width:400px"&gt; 效果如下：通过 &lt;div&gt; 标签和 align 属性控制对齐方式:1234&lt;div align="center"&gt; &lt;img src="/uploads/post/home-bg-o.jpg" style="width:300px;"&gt; &lt;img src="/uploads/post/home-bg.jpg" style="width:300px;"&gt;&lt;/div&gt;效果如下： 表格当你需要在 Markdown 文稿中键入表格，代码如下： 123456789101112131415# 第一种写法| name | age | sex || :--: | :-- | --: || tony | 18 | 男 |# 第二种写法表头1 | 表头2---- | ----Cell | Cell|# 第三种写法学号|姓名|分数-|-|-001|小明|90 name age sex tony 18 男 表头 1 表头 2 Cell Cell 学号 姓名 分数 001 小明 90 从这 3 种不同写法看，表格的格式不一定要对的非常齐，但是为了好看，对齐肯定是最好的，第一种的分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中，还是有点意思的。 强调1234*字体倾斜*_字体倾斜_**字体加粗**__字体加粗__ 效果如下： 字体倾斜字体倾斜字体加粗字体加粗 一个星号或者是一个下划线包起来，会转换为&lt;em&gt;倾斜，如果是 2 个，会转换为&lt;strong&gt;加粗。 转义12345678* \\* \`* \~* \_* \-* \+* \.* \! 效果如下： \ ` ~ _ - + . ! 就不一一列举了，基本上跟 js 转义是一样的 删除线1~~请删掉我吧~~ 效果如下： 请删掉我吧 分割线分割线的语法只需要另起一行，分割线可以由* - _（星号，减号，底线）这 3 个符号的至少 3 个符号表示，注意至少要 3 个，且不需要连续，有空格也可以。代码如下： 12345这是第一段内容---这是第二段内容 效果如下：这是第一段内容 这是第二段内容]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript有用的代码片段和trick]]></title>
    <url>%2F2018%2F08%2F22%2FJavaScript%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8Ctrick%2F</url>
    <content type="text"><![CDATA[浮点数取整12345const x = 123.4545;x &gt;&gt; 0; // 123~~x; // 123x | 0; // 123Math.floor(x); // 123 注意：前三种方法只适用于32个位整数，对于负数的处理上和 Math.floor是不同的。 12Math.floor(-12.53); // -13-12.53 | 0; // -12 生成6位数字验证码1234567891011// 方法一('000000' + Math.floor(Math.random() * 999999)).slice(-6);// 方法二Math.random().toString().slice(-6);// 方法三Math.random().toFixed(6).slice(-6);// 方法四'' + Math.floor(Math.random() * 999999); 16进制颜色代码生成1234(function() &#123; return '#'+('00000'+ (Math.random()*0x1000000&lt;&lt;0).toString(16)).slice(-6);&#125;)(); 驼峰命名转下划线1'componentMapModelRegistry'.match(/^[a-z][a-z0-9]+|[A-Z][a-z0-9]*/g).join('_').toLowerCase(); // component_map_model_registry url查询参数转json格式12345678910111213141516171819// ES6const query = (search = '') =&gt; ((querystring = '') =&gt; (q =&gt; (querystring.split('&amp;').forEach(item =&gt; (kv =&gt; kv[0] &amp;&amp; (q[kv[0]] = kv[1]))(item.split('='))), q))(&#123;&#125;))(search.split('?')[1]);// 对应ES5实现var query = function(search) &#123; if (search === void 0) &#123; search = ''; &#125; return (function(querystring) &#123; if (querystring === void 0) &#123; querystring = ''; &#125; return (function(q) &#123; return (querystring.split('&amp;').forEach(function(item) &#123; return (function(kv) &#123; return kv[0] &amp;&amp; (q[kv[0]] = kv[1]); &#125;)(item.split('=')); &#125;), q); &#125;)(&#123;&#125;); &#125;)(search.split('?')[1]);&#125;;query('?key1=value1&amp;key2=value2'); // es6.html:14 &#123;key1: "value1", key2: "value2"&#125; 获取URL参数12345678function getQueryString(key)&#123; var reg = new RegExp("(^|&amp;)"+ key +"=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if(!!r)&#123; return unescape(r[2]); &#125; return null;&#125; n维数组展开成一维数组1234567891011121314151617181920212223242526var foo = [1, [2, 3], ['4', 5, ['6',7,[8]]], [9], 10];// 方法一// 限制：数组项不能出现`,`，同时数组项全部变成了字符数字foo.toString().split(','); // ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]// 方法二// 转换后数组项全部变成数字了eval('[' + foo + ']'); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// 方法三，使用ES6展开操作符// 写法太过麻烦，太过死板[1, ...[2, 3], ...['4', 5, ...['6',7,...[8]]], ...[9], 10]; // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法四JSON.parse(`[$&#123;JSON.stringify(foo).replace(/\[|]/g, '')&#125;]`); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法五const flatten = (ary) =&gt; ary.reduce((a, b) =&gt; a.concat(Array.isArray(b) ? flatten(b) : b), []);flatten(foo); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法六function flatten(a) &#123; return Array.isArray(a) ? [].concat(...a.map(flatten)) : a;&#125;flatten(foo); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10] 注：更多方法请参考《How to flatten nested array in JavaScript?》 日期格式化12345678910111213141516171819202122232425262728293031323334353637383940// 方法一function format1(x, y) &#123; var z = &#123; y: x.getFullYear(), M: x.getMonth() + 1, d: x.getDate(), h: x.getHours(), m: x.getMinutes(), s: x.getSeconds() &#125;; return y.replace(/(y+|M+|d+|h+|m+|s+)/g, function(v) &#123; return ((v.length &gt; 1 ? "0" : "") + eval('z.' + v.slice(-1))).slice(-(v.length &gt; 2 ? v.length : 2)) &#125;);&#125;format1(new Date(), 'yy-M-d h:m:s'); // 17-10-14 22:14:41// 方法二Date.prototype.format = function (fmt) &#123; var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); &#125; for (var k in o)&#123; if (new RegExp("(" + k + ")").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); &#125; &#125; return fmt;&#125;new Date().format('yy-M-d h:m:s'); // 17-10-14 22:18:17 统计文字个数1234567891011121314151617function wordCount(data) &#123; var pattern = /[a-zA-Z0-9_\u0392-\u03c9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g; var m = data.match(pattern); var count = 0; if( m === null ) return count; for (var i = 0; i &lt; m.length; i++) &#123; if (m[i].charCodeAt(0) &gt;= 0x4E00) &#123; count += m[i].length; &#125; else &#123; count += 1; &#125; &#125; return count;&#125;var text = '贷款买房，也意味着你能给自己的资产加杠杆，能够撬动更多的钱，来孳生更多的财务性收入。';wordCount(text); // 38 特殊字符转义123456function htmlspecialchars (str) &#123; var str = str.toString().replace(/&amp;/g, "&amp;amp;").replace(/&lt;/g, "&amp;lt;").replace(/&gt;/g, "&amp;gt;").replace(/"/g, '&amp;quot;'); return str;&#125;htmlspecialchars('&amp;jfkds&lt;&gt;'); // "&amp;amp;jfkds&amp;lt;&amp;gt;" 动态插入js123456789function injectScript(src) &#123; var s, t; s = document.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = src; t = document.getElementsByTagName('script')[0]; t.parentNode.insertBefore(s, t);&#125; 格式化数量123456789101112131415161718192021222324// 方法一function formatNum (num, n) &#123; if (typeof num == "number") &#123; num = String(num.toFixed(n || 0)); var re = /(-?\d+)(\d&#123;3&#125;)/; while (re.test(num)) num = num.replace(re, "$1,$2"); return num; &#125; return num;&#125;formatNum(2313123, 3); // "2,313,123.000"// 方法二'2313123'.replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, ','); // "2,313,123"// 方法三function formatNum(str) &#123; return str.split('').reverse().reduce((prev, next, index) =&gt; &#123; return ((index % 3) ? next : (next + ',')) + prev &#125;);&#125;formatNum('2313323'); // "2,313,323" 身份证验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function chechCHNCardId(sNo) &#123; if (!this.regExpTest(sNo, /^[0-9]&#123;17&#125;[X0-9]$/)) &#123; return false; &#125; sNo = sNo.toString(); var a, b, c; a = parseInt(sNo.substr(0, 1)) * 7 + parseInt(sNo.substr(1, 1)) * 9 + parseInt(sNo.substr(2, 1)) * 10; a = a + parseInt(sNo.substr(3, 1)) * 5 + parseInt(sNo.substr(4, 1)) * 8 + parseInt(sNo.substr(5, 1)) * 4; a = a + parseInt(sNo.substr(6, 1)) * 2 + parseInt(sNo.substr(7, 1)) * 1 + parseInt(sNo.substr(8, 1)) * 6; a = a + parseInt(sNo.substr(9, 1)) * 3 + parseInt(sNo.substr(10, 1)) * 7 + parseInt(sNo.substr(11, 1)) * 9; a = a + parseInt(sNo.substr(12, 1)) * 10 + parseInt(sNo.substr(13, 1)) * 5 + parseInt(sNo.substr(14, 1)) * 8; a = a + parseInt(sNo.substr(15, 1)) * 4 + parseInt(sNo.substr(16, 1)) * 2; b = a % 11; if (b == 2) &#123; c = sNo.substr(17, 1).toUpperCase(); &#125; else &#123; c = parseInt(sNo.substr(17, 1)); &#125; switch (b) &#123; case 0: if (c != 1) &#123; return false; &#125; break; case 1: if (c != 0) &#123; return false; &#125; break; case 2: if (c != "X") &#123; return false; &#125; break; case 3: if (c != 9) &#123; return false; &#125; break; case 4: if (c != 8) &#123; return false; &#125; break; case 5: if (c != 7) &#123; return false; &#125; break; case 6: if (c != 6) &#123; return false; &#125; break; case 7: if (c != 5) &#123; return false; &#125; break; case 8: if (c != 4) &#123; return false; &#125; break; case 9: if (c != 3) &#123; return false; &#125; break; case 10: if (c != 2) &#123; return false; &#125;; &#125; return true;&#125; 测试质数123function isPrime(n) &#123; return !(/^.?$|^(..+?)\1+$/).test('1'.repeat(n))&#125; 统计字符串中相同字符出现的次数1234567var arr = 'abcdaabc';var info = arr .split('') .reduce((p, k) =&gt; (p[k]++ || (p[k] = 1), p), &#123;&#125;);console.log(info); //&#123; a: 3, b: 2, c: 2, d: 1 &#125; 使用void 0来解决undefined被污染问题123undefined = 1;!!undefined; // true!!void(0); // false 单行写一个评级组件1"★★★★★☆☆☆☆☆".slice(5 - rate, 10 - rate); JavaScript 错误处理的方式的正确姿势1234567try &#123; something&#125; catch (e) &#123; window.location.href = "http://stackoverflow.com/search?q=[js]+" + e.message;&#125; 匿名函数自执行写法1234567891011121314151617181920( function() &#123;&#125;() );( function() &#123;&#125; )();[ function() &#123;&#125;() ];~ function() &#123;&#125;();! function() &#123;&#125;();+ function() &#123;&#125;();- function() &#123;&#125;();delete function() &#123;&#125;();typeof function() &#123;&#125;();void function() &#123;&#125;();new function() &#123;&#125;();new function() &#123;&#125;;var f = function() &#123;&#125;();1, function() &#123;&#125;();1 ^ function() &#123;&#125;();1 &gt; function() &#123;&#125;(); 两个整数交换数值1234567var a = 20, b = 30;a ^= b;b ^= a;a ^= b;a; // 30b; // 20 数字字符转数字12var a = '1';+a; // 1 最短的代码实现数组去重1[...new Set([1, "1", 2, 1, 1, 3])]; // [1, "1", 2, 3] 用最短的代码实现一个长度为m(6)且值都n(8)的数组1Array(6).fill(8); // [8, 8, 8, 8, 8, 8] 将argruments对象转换成数组1234567var argArray = Array.prototype.slice.call(arguments);// ES6：var argArray = Array.from(arguments)// orvar argArray = [...arguments]; 获取日期时间缀12345678// 获取指定时间的时间缀new Date().getTime();(new Date()).getTime();(new Date).getTime();// 获取当前的时间缀Date.now();// 日期显示转换为数字+new Date(); 使用~x.indexOf(&#39;y&#39;)来简化x.indexOf(&#39;y&#39;) &gt; -12345678var str = 'hello world';if (str.indexOf('lo') &gt; -1) &#123; // ...&#125;if (~str.indexOf('lo')) &#123; // ...&#125; parseInt() or Number()两者的差别之处在于解析和转换两者之间的理解。 解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否者会失败并返回NaN。 12345678var a = '520';var b = '520px';Number(a); // 520parseInt(a); // 520Number(b); // NaNparseInt(b); // 520 parseInt方法第二个参数用于指定转换的基数，ES5默认为10进制。1234parseInt('10', 2); // 2parseInt('10', 8); // 8parseInt('10', 10); // 10parseInt('10', 16); // 16 对于网上parseInt(0.0000008)的结果为什么为8，原因在于0.0000008转换成字符为”8e-7”，然后根据parseInt的解析规则自然得到”8”这个结果。 +拼接操作，+x or String(x)？+运算符可用于数字加法，同时也可以用于字符串拼接。如果+的其中一个操作符是字符串(或者通过 隐式强制转换可以得到字符串)，则执行字符串拼接；否者执行数字加法。 需要注意的时对于数组而言，不能通过valueOf()方法得到简单基本类型值，于是转而调用toString()方法。1[1,2] + [3, 4]; // "1,23,4" 对于对象同样会先调用valueOf()方法，然后通过toString()方法返回对象的字符串表示。 12var a = &#123;&#125;;a + 123; // "[object Object]123" 对于a + &quot;&quot;隐式转换和String(a)显示转换有一个细微的差别：a + &#39;&#39;会对a调用valueOf()方法，而String()直接调用toString()方法。大多数情况下我们不会考虑这个问题，除非真遇到。 1234567var a = &#123; valueOf: function() &#123; return 42; &#125;, toString: function() &#123; return 4; &#125;&#125;a + ''; // 42String(a); // 4 判断对象的实例1234567891011121314151617181920212223242526// 方法一: ES3function Person(name, age) &#123; if (!(this instanceof Person)) &#123; return new Person(name, age); &#125; this.name = name; this.age = age;&#125;// 方法二: ES5function Person(name, age) &#123; var self = this instanceof Person ? this : Object.create(Person.prototype); self.name = name; self.age = age; return self;&#125;// 方法三：ES6function Person(name, age) &#123; if (!new.target) &#123; throw 'Peron must called with new'; &#125; this.name = name; this.age = age;&#125; 数据安全类型检查1234567891011121314// 对象function isObject(value) &#123; return Object.prototype.toString.call(value).slice(8, -1) === 'Object'';&#125;// 数组function isArray(value) &#123; return Object.prototype.toString.call(value).slice(8, -1) === 'Array';&#125;// 函数function isFunction(value) &#123; return Object.prototype.toString.call(value).slice(8, -1) === 'Function';&#125; 让数字的字面值看起来像对象123452.toString(); // Uncaught SyntaxError: Invalid or unexpected token2..toString(); // 第二个点号可以正常解析2 .toString(); // 注意点号前面的空格(2).toString(); // 2先被计算 对象可计算属性名(仅在ES6中)12345678var suffix = ' name';var person = &#123; ['first' + suffix]: 'Nicholas', ['last' + suffix]: 'Zakas'&#125;person['first name']; // "Nicholas"person['last name']; // "Zakas" 数字四舍五入12345678// v: 值，p: 精度function (v, p) &#123; p = Math.pow(10, p &gt;&gt;&gt; 31 ? 0 : p | 0) v *= p; return (v + 0.5 + (v &gt;&gt; 31) | 0) / p&#125;round(123.45353, 2); // 123.45 在浏览器中根据url下载文件12345678910111213141516171819202122232425262728function download(url) &#123; var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') &gt; -1; var isSafari = navigator.userAgent.toLowerCase().indexOf('safari') &gt; -1; if (isChrome || isSafari) &#123; var link = document.createElement('a'); link.href = url; if (link.download !== undefined) &#123; var fileName = url.substring(url.lastIndexOf('/') + 1, url.length); link.download = fileName; &#125; if (document.createEvent) &#123; var e = document.createEvent('MouseEvents'); e.initEvent('click', true, true); link.dispatchEvent(e); return true; &#125; &#125; if (url.indexOf('?') === -1) &#123; url += '?download'; &#125; window.open(url, '_self'); return true;&#125; 快速生成UUID1234567891011function uuid() &#123; var d = new Date().getTime(); var uuid = 'xxxxxxxxxxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) &#123; var r = (d + Math.random() * 16) % 16 | 0; d = Math.floor(d / 16); return (c == 'x' ? r : (r &amp; 0x3 | 0x8)).toString(16); &#125;); return uuid;&#125;;uuid(); // "33f7f26656cb-499b-b73e-89a921a59ba6" JavaScript浮点数精度问题12345678910function isEqual(n1, n2, epsilon) &#123; epsilon = epsilon == undefined ? 10 : epsilon; // 默认精度为10 return n1.toFixed(epsilon) === n2.toFixed(epsilon);&#125;0.1 + 0.2; // 0.30000000000000004isEqual(0.1 + 0.2, 0.3); // true0.7 + 0.1 + 99.1 + 0.1; // 99.99999999999999isEqual(0.7 + 0.1 + 99.1 + 0.1, 100); // true 格式化表单数据12345678910111213141516171819202122232425262728293031323334353637383940function formatParam(obj) &#123; var query = '', name, value, fullSubName, subName, subValue, innerObj, i; for(name in obj) &#123; value = obj[name]; if(value instanceof Array) &#123; for(i=0; i&lt;value.length; ++i) &#123; subValue = value[i]; fullSubName = name + '[' + i + ']'; innerObj = &#123;&#125;; innerObj[fullSubName] = subValue; query += formatParam(innerObj) + '&amp;'; &#125; &#125; else if(value instanceof Object) &#123; for(subName in value) &#123; subValue = value[subName]; fullSubName = name + '[' + subName + ']'; innerObj = &#123;&#125;; innerObj[fullSubName] = subValue; query += formatParam(innerObj) + '&amp;'; &#125; &#125; else if(value !== undefined &amp;&amp; value !== null) query += encodeURIComponent(name) + '=' + encodeURIComponent(value) + '&amp;'; &#125; return query.length ? query.substr(0, query.length - 1) : query;&#125;var param = &#123; name: 'jenemy', likes: [0, 1, 3], memberCard: [ &#123; title: '1', id: 1 &#125;, &#123; title: '2', id: 2 &#125; ]&#125;formatParam(param); // "name=12&amp;likes%5B0%5D=0&amp;likes%5B1%5D=1&amp;likes%5B2%5D=3&amp;memberCard%5B0%5D%5Btitle%5D=1&amp;memberCard%5B0%5D%5Bid%5D=1&amp;memberCard%5B1%5D%5Btitle%5D=2&amp;memberCard%5B1%5D%5Bid%5D=2" 创建指定长度非空数组在JavaScript中可以通过new Array(3)的形式创建一个长度为3的空数组。在老的Chrome中其值为[undefined x 3]，在最新的Chrome中为[empty x 3]，即空单元数组。在老Chrome中，相当于显示使用[undefined, undefined, undefined]的方式创建长度为3的数组。 但是，两者在调用map()方法的结果是明显不同的 12345var a = new Array(3);var b = [undefined, undefined, undefined];a.map((v, i) =&gt; i); // [empty × 3]b.map((v, i) =&gt; i); // [0, 1, 2] 多数情况我们期望创建的是包含undefined值的指定长度的空数组，可以通过下面这种方法来达到目的： 1234var a = Array.apply(null, &#123; length: 3 &#125;);a; // [undefined, undefined, undefined]a.map((v, i) =&gt; i); // [0, 1, 2] 总之，尽量不要创建和使用空单元数组。 debounce方法debounce()方法用来延迟执行函数。12345678910111213141516171819var debounce = function (func, threshold, execAsap) &#123; var timeout; return function debounced() &#123; var obj = this, args = arguments; function delayed() &#123; if (!execAsap) func.apply(obj, args); timeout = null; &#125;; if (timeout) clearTimeout(timeout); else if (execAsap) func.apply(obj, args); timeout = setTimeout(delayed, threshold || 100); &#125;;&#125; 判断客户端123456789101112131415161718192021222324var browser = &#123; v: (function() &#123; var u = navigator.userAgent, app = navigator.appVersion, p = navigator.platform; return &#123; trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否iPad weixin: u.indexOf('MicroMessenger') &gt; -1, //是否微信 webApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部 UCB: u.match(/UCBrowser/i) == "UCBrowser", QQB: u.match(/MQQBrowser/i) == "MQQBrowser", win: p.indexOf('Win') &gt; -1, //判断是否是WIN操作系统 mac: p.indexOf('Mac') &gt; -1 //判断是否是Mac操作系统 &#125;; &#125;)()&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用图标和示例解释Await和Async]]></title>
    <url>%2F2018%2F08%2F18%2F%E7%94%A8%E5%9B%BE%E6%A0%87%E5%92%8C%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8AAwait%E5%92%8CAsync%2F</url>
    <content type="text"><![CDATA[简介JavaScript ES7 中的 async / await 让多个异步 promise 协同工作起来更容易。如果要按一定顺序从多个数据库或者 API 异步获取数据，你可能会以一堆乱七八糟的 promise 和回调函数而告终。而 async / await 结构让我们能用可读性强、易维护的代码更加简洁地实现这些逻辑。 本教程用图表和简单示例讲解了 JavaScript 中 async / await 的语法和语义。 在深入之前，我们先简单回顾一下 promise. 如果你已经对 JS 的 promise 有所了解，可放心大胆地跳过这一部分。 Promises在 JavaScript 中，promise 代表非阻塞异步执行的抽象概念。如果你熟悉 Java 的 Future、C# 的 Task, 你会发现 promise 跟它们很像。 Promise 一般用于网络和 I/O 操作，比如读取文件，或者创建 HTTP 请求。我们可以创建异步 promise，然后用 then 添加一个回调函数，当 promise 结束后会触发这个回调函数，而非阻塞住当前“线程”。回调函数本身也可以返回一个 promise 对象，所以我们能够链式调用 promise。 为了简单起见，我们假设后面所有示例都已经像这样安装并加载了 request-promise 类库： 1var rp = require("request-promise"); 现在我们就可以像这样创建一个返回 promise 对象的简易 HTTP GET 请求： 1const promise = rp("http://example.com/"); 我们现在来看个例子： 123456console.log("Starting Execution");const promise = rp("http://example.com/");promise.then(result =&gt; console.log(result));console.log("Can't know if promise has finished yet..."); 我们在第 3 行创建了一个 promise 对象，在第 4 行给它加了个回调函数。Promise 是异步的，所以当执行到第 6 行时，我们并不知道 promise 是否已完成。如果把段这代码多执行几次，可能每次都得到不同的结果。一般地说，就是 promise 创建后的代码和 promise 是同时运行的。 直到 promise 执行完，才有办法阻塞当前操作序列。这不同于 Java 的 Future.get, 它让我们能够在 Future 结束之前就阻塞当前线程。对于 JavaScript，我们没法等待 promise 执行完。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。 下图描述了本例的计算过程： Promise 的计算过程。正在执行的“线程”无法等待 promise 执行完成。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。 通过 then 添加的回调函数只有当 promise 成功时才会执行。如果它失败了（比如由于网络错误），回调函数不会执行。你可以用 catch 再附加一个回调函数来处理失败的 promise: 123rp("http://example.com/") .then(() =&gt; console.log("Success")) .catch(e =&gt; console.log(`Failed: $&#123;e&#125;`)); 最后，为了测试，我们可以用 Promise.resolve 和 Promise.reject 很容易地创建执行成功或失败的“傻瓜” promise: 1234567891011const success = Promise.resolve("Resolved");// 打印 "Successful result: Resolved"success .then(result =&gt; console.log(`Successful result: $&#123;result&#125;`)) .catch(e =&gt; console.log(`Failed with: $&#123;e&#125;`));const fail = Promise.reject("Err");// 打印 "Failed with: Err"fail .then(result =&gt; console.log(`Successful result: $&#123;result&#125;`)) .catch(e =&gt; console.log(`Failed with: $&#123;e&#125;`)); 想要更详细的 promise 教程，可以参考这篇文章。 问题来了——组合 promise只用一个 promise 很容易搞定。但是，当需要针对复杂异步逻辑编程时，我们很可能最后要同时用好几个 promise 对象。写一堆 then 语句和匿名回调很容易搞得难以控制。 例如，假设我们需要编程解决如下需求： 创建 HTTP 请求，等待请求结束并打印出结果； 再创建两个并行 HTTP 请求； 等这两个请求结束后，打印出它们的结果。 下面这段代码示范了如何解决此问题： 1234567891011121314151617// 第一次调用const call1Promise = rp("http://example.com/");call1Promise .then(result1 =&gt; &#123; // 第一个请求完成后会执行 console.log(result1); const call2Promise = rp("http://example.com/"); const call3Promise = rp("http://example.com/"); return Promise.all([call2Promise, call3Promise]); &#125;) .then(arr =&gt; &#123; // 两个 promise 都结束后会执行 console.log(arr[0]); console.log(arr[1]); &#125;); 我们开头创建了第一个 HTTP 请求，并且加了个完成时候运行的回调（1-3 行）。在这个回调函数里，我们为随后的 HTTP 请求创建了另外两个 promise（8-9 行）。这两个 promise 同时执行，我们需要加一个能等它们都完成后才执行的回调函数。因此，我们需要用 Promise.all 将它们组合到同一个 promise 中（11 行），它们都结束后这个 promise 才算完成。这个回调返回的是 promise 对象，所以我们要再加一个 then 回调函数来打印结果（12-16 行）。 下图描述了这一计算流程： Promise 组合的计算过程。我们用 Promise.all 将两个并行的 promise 组合到一个 promise 中。 对于这个简单的例子，我们最后用了两个 then 回调方法，并且不得不用 Promise.all 来让两个并行的 promise 同时执行。如果我们必须执行更多异步操作，或者加上错误处理会怎么样呢？这种方法最后很容易产生一堆乱七八糟的 then, Promise.all 和回调函数。 Async 方法Async 是定义返回 promise 对象函数的快捷方法。 例如，下面这两种定义是等价的： 12345678function f() &#123; return Promise.resolve("TEST");&#125;// asyncF 和 f 是等价的async function asyncF() &#123; return "TEST";&#125; 类似地，抛出异常的 async 方法等价于返回拒绝 promise 的方法： 12345678function f() &#123; return Promise.reject("Error");&#125;// asyncF 和 f 是等价的async function asyncF() &#123; throw "Error";&#125; Await我们创建了 promise 但不能同步等待它执行完成。我们只能通过 then 传一个回调函数。不允许等待 promise 是为了鼓励开发非阻塞代码。否则，开发者们总会忍不住执行阻塞操作，因为那比使用 promise 和回调更简单。 然而，为了让 promise 能同步执行，我们需要让他们等待彼此完成。换句话说，如果一个操作是异步的（即封装在 promise 中），它应该能够等待另一个异步操作执行完。但是 JavaScript 解释器怎么能知道一个操作是否在 promise 中运行呢？ 答案就在 async 这个关键词中。每个 async 方法都返回一个 promise 对象。因此，JavaScript 解释器就明白所有 async 方法中的操作都被封装在 promise 里异步执行。所以解释器能够允许它们等待其他 promise 执行完。 下面引入 await 关键词。它只能被用在 async 方法中，让我们能同步等待 promise 执行完。如果在 async 函数外使用 promise, 我们仍然需要用 then 回调函数： 123456789async function f() &#123; // response 就是 promise 执行成功的值 const response = await rp("http://example.com/"); console.log(response);&#125;// 不能在 async 方法外面用 await// 需要使用 then 回调函数……f().then(() =&gt; console.log("Finished")); 现在我们来看如何解决上一节的问题： 12345678910111213141516171819// 将解决方法封装到 async 函数中async function solution() &#123; // 等待第一个 HTTP 请求并打印出结果 console.log(await rp("http://example.com/")); // 创建两个 HTTP 请求，不等它们执行完 —— 让他们同时执行 const call2Promise = rp("http://example.com/"); // Does not wait! const call3Promise = rp("http://example.com/"); // Does not wait! // 创建完以后 —— 等待它们都执行完 const response2 = await call2Promise; const response3 = await call3Promise; console.log(response2); console.log(response3);&#125;// 调用这一 async 函数solution().then(() =&gt; console.log("Finished")); 上面这段代码中，我们把解决方法封装到 async 函数中。这让我们能直接对里面的 promise 使用 await 关键字，所以不再需要使用 then 回调函数。最后，调用这个 async 函数，它简单地创建了一个 promise 对象, 这个 promise 封装了调用其他 promise 的逻辑。 当然，在第一个例子（没有用 async / await）中，两个 promise 会被同时触发。这段代码也一样（7-8 行）。注意，直到第 11-12 行我们才使用 await, 将程序一直阻塞到两个 promise 执行完成。然后我们就能断定上例中两个 promise 都成功执行了（和使用 Promise.all(…).then(…) 类似）。 这背后的计算过程跟上一节给出的基本相当。但是代码可读性更强、更易于理解。 实际上，async / await 在底层转换成了 promise 和 then 回调函数。也就是说，这是使用 promise 的语法糖。每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。 我们再看看下面的例子： 12345async function f() &#123; console.log("Starting F"); const result = await rp("http://example.com/"); console.log(result);&#125; 下面给出了函数 f 底层运算过程。由于 f 是 async 的，所以它会跟它的调用方同时执行： Await 的计算过程 函数 f 开始运行并创建了一个 promise 对象。就在那一刻，函数中剩下的部分被封装到一个回调函数中，并在 promise 结束后执行。 错误处理前面大部分例子中，我们都假设 promise 执行成功。因此在 promise 上使用 await 会返回值。如果我们进行 await 的 promise 失败了，async 函数就会发生异常。我们可以用标准的 try / catch 来处理这种情况： 1234567async function f() &#123; try &#123; const promiseResult = await Promise.reject("Error"); &#125; catch (e) &#123; console.log(e); &#125;&#125; Async 函数不会处理异常，不管异常是由拒绝的 promise 还是其他 bug 引起的，它都会返回一个拒绝 promise: 123456789101112131415161718async function f() &#123; // Throws an exception const promiseResult = await Promise.reject("Error");&#125;// Will print "Error"f() .then(() =&gt; console.log("Success")) .catch(err =&gt; console.log(err));async function g() &#123; throw "Error";&#125;// Will print "Error"g() .then(() =&gt; console.log("Success")) .catch(err =&gt; console.log(err)); 结论Async / await 是让 promise 更完美的语言结构。它让我们能用更少的代码使用 promise. 然而，async / await 并没有取代普通 promise. 例如，如果在普通函数中或者全局范围内调用 async 函数，我们就没办法使用 await 而要依赖于普通 promise: 1234567async function fAsync() &#123; // actual return value is Promise.resolve(5) return 5;&#125;// can't call "await fAsync()". Need to use then/catchfAsync().then(r =&gt; console.log(`result is $&#123;r&#125;`)); 我通常会将大部分异步逻辑封装到一个或者几个 async 函数中，然后在非异步代码中调用。这让我尽可能少地写 try / catch 回调。 Async / await 结构是让使用 promise 更简练的语法糖。每一个 async / await 结构都可以写成普通 promise. 归根结底，这是一个编码风格和简洁的问题。 关于说明并发和并行有区别的资料，可以查看 Rob Pike 关于这个问题的讨论，或者我这篇文章。并发是指将独立进程（通常意义上的进程）组合在一起工作，而并行是指真正同时处理多个任务。并发关乎应用设计和架构，而并行关乎实实在在的执行。 我们拿一个多线程应用来举例。应用程序分离成线程明确了它的并发模型。这些线程在可用内核上的映射定义了其级别或并行性。并发系统可以在单个处理器上高效运行，在这种情况下，它并不是并行的。 并发 VS 并行从这个意义上说，promise 让我们能够将程序分解成并发模块，这些模块可能会也可能不会并行执行。Javascript 实际否并行执行取决于具体实现方法。例如，Node JS 是单线程的，如果 promise 是计算密集型（CPU bound）那就不会有并行处理。但是，如果你用 Nashorn 之类的东西把代码编译成 java 字节码，理论上可能能够将计算密集型的 promise 映射到不同 CPU 核上，从而达到并行效果。所以我认为，promise（不管是普通的还是用了 async / await 的）组成了 JavaScript 应用的并发模块。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es7</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo,创建属于你自己的博客]]></title>
    <url>%2F2018%2F08%2F16%2FHexo-%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言欢迎来到 Hexo！该文章非常适合不懂前端的人搭建自己的博客，接下来我会讲解我为什么会选择hexo和hexo博客搭建步奏。最近想要搞个个人博客，因为不想自己搞站点，所以找到了github pages，它提供给我们域名和空间，多省事啊。那静态页面用什么工具呢？一开始我用的是jekyll,然后我有了那句经典的感受，那句话是从入门到放弃，啊，多么痛的领悟！ 下面我来扒一扒： jekyll需要安装ruby,python等，hexo需要nodejs，当然为了 push 到 github 都需要装个git,速度上jekyll生成静态站点的速度比hexo慢多了，如果你时间多。 便捷性，hexo完爆jekyll，同样是 quick start，虽然都是几个命令，就可以预览效果了，但是效果差了十万八千里。 插件和样式，你写完 post，想做个 categories？对于hexo就是 so easy，在你的文章前面的使用 category: 分类名，hexo就给你在右边生成，包括分类主页，默认样式，你啥都不用干。而jekyll需要自己写标签语言遍历然后在创建各个分类的主页，在设置页面 css，或者用 ruby 写插件去搞，这下老子要骂娘了，我他妈根本不会 ruby 啊，官方为什么不主动提供好现成的插件？我只是个后端工程师，不是全栈，页面+css 真的玩不来，不知道提供些 theme 供人选择？ 废话不多说，接下来会以我的博客为例子搭建一个 hexo 的 github pages！ Hexo 相关命令总结1234567891011121314151617$ hexo init #初始化一个项目$ hexo new page "xxx" #生成页面$ hexo new "" #生成文章$ hexo clean #清除缓存$ hexo s #启动本地服务$ hexo g #保存修改，生成文件$ hexo d #发布到远程$ npm install --save xxx #安装插件$ npm unstall xxx #卸载插件 上述命令将贯穿于整个博客过程，不难，能动手尽量别复制粘贴 准备工作安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。 cURL: 1curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: 1wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1nvm install stable 或者您也可以下载 安装程序 来安装。 Windows 用户对于 windows 用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是 git for windows 自带的一组程序，提供了 Linux 风格的 shell，在该环境下，您可以直接用上面提到的命令来安装 Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于 Hexo 的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1npm install -g hexo-cli 用法在这里以HUX博客主题为例子(也可以按 hexo 官方文档进行搭建)，移植的主题 Hux Blog，我为了您的方便而发布整个项目，因此您只需按照下面的说明操作，即可轻松自定义您自己的博客！ 让我们开始！！！ 初始化123git clone https://github.com/csjiabin/hexo-theme-hux.gitcd hexo-theme-huxnpm install 站点配置你可以通用修改 _config.yml 文件来轻松的开始搭建自己的博客: 123456789101112131415title: xxx # 博客名，站点名称author: xxx # 博客作者名字 #description: xxx # 对站点的描述，搜索引擎会抓取，可以自定义keyword: xxx # 向搜索引擎说明你的网页的关键词theme: huxblog # themes目录下的主题目录# 您可以决定是否显示侧边栏# Sidebar settingssidebar: true # whether or not using Sidebar.sidebar-about-description: "Goals determine what you going to be!!"sidebar-avatar: https://avatars1.githubusercontent.com/u/20592953?s=460&amp;v=4 # use absolute URL, seeing it's used in both `/` and `/about/# 您可以决定是否显示帖子标签。# Featured Tagsfeatured-tags: true # whether or not using Feature-Tags 撰写博文1hexo new post &lt;post name&gt; # 或者`hexo new &lt;post name&gt;`生成文章 要发表的文章一般以 Markdown 的格式放在这里_posts/，你只要看看这篇模板里的文章你就立刻明白该如何设置。 不同Markdown格式语法的可以看这篇 文章 &rarr; 12345678title: "&lt;post name&gt;"catalog: trueauthor: CSjiabinheader-img: /img/home-bg.jpgdate: 2018-08-16 22:58:09tags: - hexo--- 启动本地服务调试 1hexo s --debug –debug 调试模式，会监听文件的变动进行重启，但不会监听最外层的_config.yml文件 开启评论功能 首先，你需要去注册一个 Disqus 帐号。不要直接使用我的啊！ 其次，你只需要在下面的 _config.yml 文件中设置一下就可以了。 123# 评论系统# Disqus（https://disqus.com/)disqus_username: csjiabin 另外你可以其他评论系统使用，例： Gitalk、多说 等 部署到 github上面所有的操作完成之后，你就可以将你的 Blog 项目部署到 github 上了。部署之前先修改_config.yml文件。 1234deploy: type: git repo: https://github.com/&lt;yourAccount&gt;/&lt;repo&gt; branch: &lt;your-branch&gt; 备注：在 hexo3.x 版本下，这里的 type 应该填 git，不是 github；另外冒号后面都有一个英文的空格，不然会报错的。 配置完_config.yml文件后，在命令后执行以下命令： 12hexo generate(g) # 把文章生成页面hexo deploy(d) # 部署到github可与hexo g合并为 hexo d -g Have fun ^_^如果你喜欢这个项目请给我点个Star吧！Following 也将不胜感激!如有其他疑问可以给我留言，我会第一时间为您解答！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
</search>
